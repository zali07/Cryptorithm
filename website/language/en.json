{
  "base": {
    "crypt": "Crypt",
    "learning": "Learning",
    "logout": "Logout",
    "login": "Login",
    "submit": "Submit"
  },
  "cryptorithm": {
    "login": "Login",
    "email": "Email",
    "password": "Password",
    "no_account": "Don't have an account?",
    "signup": "Sign Up",
    "password_confirm": "Password (Confirm)",
    "already_account": "Already have an account?"
  },
  "home": {
    "history": "History",
    "choose": "Choose an algortihm: "
  },
  "learning": {
    "learn_about": "Learn about!",
    "list1": "Data Transformation",
    "list2": "Hash",
    "list3": "Block Cipher"
  },
  "caesar": {
    "title1": "Caesar - Origin",
    "title2": "Caesar - Description",
    "title3": "Caesar - Key / Security",
    "title1_1": "The Caesar cipher is named after Julius Caesar, the ancient Roman military and political leader who is believed to have used this encryption technique. The cipher is attributed to him, although it is likely that similar techniques were used even earlier. Julius Caesar used the Caesar cipher to protect sensitive military information during his campaigns. The shift of letters provided a simple and effective way to conceal messages from enemies who might intercept them.",
    "title1_2": "The method involves shifting each letter in the plaintext by a fixed number of positions, with Caesar's preferred shift being three positions. For example, if the plaintext is \"ATTACK AT DAWN\", the ciphertext generated using Caesar's cipher is \"DWWDFN DW GDZQ\".",
    "title2_1": "Each letter is encrypted one by one with a different letter, i.e. the letters are replaced one by one by the letter code assigned to them, always assigning the same letter code to a letter. Which letter is replaced by which letter is determined by the key k, which is an integer in the original system. A letter will thus always be replaced by a letter k positions to the right of the letter, and it is assumed that the letters are arranged in a circle, i.e. the letter A is again placed after the letter Z.",
    "title2_2": "Mathematically, it is defined by the following formula, where the letter p is the numeric code, the letter k is the offset value (key) and c is the secret numeric code:",
    "title2_3": "The decryption formula is the inverse of this, assuming that the encrypted letter is c, then the mathematical formula is:",
    "title3_1": "The key in the Caesar cipher is the number of positions each letter is shifted. For example, a key of 3 means each letter is shifted three positions down the alphabet.",
    "title3_2": "The Caesar cipher is a very basic and easily breakable cipher. It has only 26 possible keys, making it vulnerable to brute-force attacks. It is often used as an introductory example in cryptography, but it is not secure for practical purposes."
  },
  "affin": {
    "title1": "Affin - Origin",
    "title2": "Affin - Description",
    "title3": "Affin - Security / Example",
    "title1_1": "The Affine cipher has its roots in ancient civilizations. It is believed to have been used by the Romans around the 1st century BC. The Roman military commander Julius Caesar is often associated with an early version of the Affine cipher, known as the Caesar cipher or Caesar's cipher.",
    "title1_2": "The concept of the Affine cipher as a generalization of the Caesar cipher emerged later. The Affine cipher was developed as a more advanced cryptographic technique that allowed for a wider range of encryption possibilities.",
    "title2_1": "The Affine cipher is based on the mathematical concept of an affine transformation. An affine transformation is a linear function that combines two operations: a multiplication (modular arithmetic) and an addition (modulo operation).",
    "title2_2": "The parameters used in the Affine cipher are the encryption key ('a') and the modular arithmetic base ('b'). Assuming that 'p' is the numerical code of a letter in the plaintext and 'c' is its corresponding to the encrypted numeric code, the encryption formula is as follows:",
    "title2_3a": "If the",
    "title2_3b": "is the multiplicative inverse of the number 'a' according to 26, i.e the following relation holds:",
    "title2_4": "then the decryption formula will be:",
    "title3_1": "Over time, cryptanalysts have developed techniques to break the Affine cipher. The simplicity of the algorithm and the limited key space make it susceptible to brute-force attacks and frequency analysis methods.",
    "title3_2": "Although the Affine cipher is no longer considered secure for modern cryptographic purposes, it is still studied and used in educational settings to illustrate fundamental concepts of encryption and decryption. It serves as an introduction to more complex ciphers and cryptographic techniques."
  },
  "aes": {
    "title1": "AES Origin",
    "title2": "AES-CTR Description",
    "title3": "AES-CTR Security",
    "title1_1": "AES (Advanced Encryption Standard), also known as Rijndael, is a symmetric block cipher cryptosystem, which was standardized by the NIST in 2001. The system was developed by two Belgian cryptographers, Vincent Rijmen and Joan Daemen, and the name Rijndael is a contraction of their names.",
    "title1_2": "The block ciphers are schemes for encryption or decryption where a block of plaintext is treated as a single block and is used to obtain a block of ciphertext with the same size. Today, AES is one of the most used algorithms for block encryption. The size of an AES block is 128 bits, whereas the size of the encryption key can be 128, 192 or 256 bits. Please note this, there is three length in the key, but the size of the encryption block always is 128 bits.",
    "title1_3a": "Five modes: ECB, CBC, CFB, OFB, CTR",
    "title1_3b": "In this case we are discussing the CTR (short for counter) mode. At this mode of operation as an input block to the encryptor, i.e. as an IV, the value of a counter (Counter, Counter + 1,…, Counter + N - 1) is used. It also is a stream encryptor.",
    "title1_4a": "Pros:",
    "title1_4b": "- No padding",
    "title1_4c": "- Supports parallel computing",
    "title1_4d": "- Encryption and decryption use the same structure",
    "title1_4e": "- Bad block only affect the current block",
    "title1_4f": "Cons:",
    "title1_4g": "- A MITM (Man in the Middle) can change some ciphertext damaged plaintext",
    "title2_1": "A secret symmetric key is generated or provided. The AES algorithm takes this key and expands it into a set of round keys that will be used in the subsequent encryption process.",
    "title2_2": "An Initialization Vector is a unique value that is required for the CTR mode. The IV can be generated randomly or derived from a nonce (number used once) and a counter. The IV should be unique for each encryption operation to maintain security. The counter value is initialized based on the IV. The counter is a unique value that is incremented for each block of plaintext or ciphertext.",
    "title2_3": "AES-CTR operates by dividing the plaintext into fixed-size blocks (e.g., 128 bits). For each block, the counter value is encrypted using the AES algorithm and the round keys generated in the key expansion phase. This encryption of the counter produces a pseudorandom keystream.",
    "title2_4": "The pseudorandom keystream generated from the encryption step is then XORed with the corresponding plaintext block. The result of the XOR operation is the ciphertext block. This process is repeated for each block of plaintext, generating the complete ciphertext.",
    "title2_5a": "After each encryption or decryption operation, the counter value is incremented to ensure that a unique value is used for each block.",
    "title2_5b": "By using this process, AES-CTR transforms the AES block cipher into a stream cipher, generating a pseudorandom keystream that is combined with the plaintext or ciphertext through the XOR operation.",
    "title3_1": "To ensure security, the key in this mode need to be changed for every 2^(n/2) encryption blocks.",
    "title3_2a": "Attack modes:",
    "title3_2b": "- PA (Padding Attack)",
    "title3_2c": "- CPA (Chose Plaintext Attack)",
    "title3_2d": "- CCA (Choosen Ci)",
    "title3_3a": "It's commonly useid in:",
    "title3_3b": "- Network Communication",
    "title3_3c": "- Disk and File Encryption",
    "title3_3d": "- Cloud Storage",
    "title3_3e": "- Real-Time Media Encryption",
    "title3_3f": "- Wireless Security"
  },
  "sha1": {
    "title1": "SHA-1 Origin",
    "title2": "SHA-1 Description",
    "title3": "SHA-1 Security",
    "title1_1a": "The SHA-1 (Secure Hash Algorithm 1) hash function, designed by the ",
    "title1_1b": "takes an input and produces a 160-bit (20-byte) hash value known as a message digest - typically rendered as 40 hexadecimal digits. SHA-1 is the most established of the existing SHA hash functions and it is used in a variety of security applications and protocols. However, SHA-1's collision resistance has been weakening as new attacks are discovered or improved.",
    "title2_1": "The input message is processed in blocks of 512 bits. If the message length is not a multiple of 512 bits, padding is added to the message to bring it to the appropriate length. The padding includes a \"1\" bit followed by a series of \"0\" bits, and the length of the original message is appended.",
    "title2_2a": "This algorithm requires two buffers and a long sequence of 32-bit words:",
    "title2_2b": "The two five 32-bit registers (“A, B, C, D, E” and “H0, H1, H2, H3, H4”) have specific initial values, and the sequence of 80 32-bit words (W[0], W[1], W[2]… W[78], W[79]).",
    "title2_3": "The core of the SHA-1 algorithm is a compression function that operates on a 160-bit message block and the current state of the message digest. It performs a series of operations, including bitwise logical functions, message expansion, and modular addition.",
    "title2_4": "The compression function is applied iteratively to each message block, updating the message digest state as each block is processed. The final output is the hash value of the input message.",
    "title2_5": "Each block goes through a complex process of expansion and 80 rounds of compression of 20 steps each. The value obtained after each compression is added to the current buffer (hash state).",
    "title2_6": "The resulting hash value is a fixed-size digest of 160 bits. It represents a unique fingerprint of the input message, making it highly improbable for two different messages to produce the same hash value.",
    "title3_1": "One of the main vulnerabilities of SHA-1 is its reduced collision resistance. A collision occurs when two different inputs produce the same hash output. In 2005, researchers demonstrated a theoretical collision attack on SHA-1, and in 2017, an actual collision attack was successfully executed, highlighting the practical security risks.",
    "title3_2": "Due to the identified vulnerabilities, SHA-1 is considered deprecated and not recommended for use in new cryptographic applications. Instead, stronger hash functions like SHA-256 or higher certificates are advised for improved security.",
    "title3_3a": "Widely used in:",
    "title3_3b": "- Security applications and protocols (e.g., TLS, SSL, PGP, SSH, S/MIME, Ipsec)",
    "title3_3c": "- Cryptocurrencies transactions validation",
    "title3_3d": "- Digital certificates"
  },
  "sha2": {
    "title1": "SHA-2 Origin",
    "title2": "SHA-2 Description",
    "title3": "SHA-2 Security / Usage",
    "title1_1": "The successor of SHA-1, approved and recommended by NIST, SHA-2 is a family of six algorithms with different digest sizes (in bits): SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256. The first four use the same construction with different output sizes, while the last two are truncated versions of SHA-512, where the initial values are generated using the method described in",
    "title1_2a": "Three main purposes of a hash function are:",
    "title1_2b": "- To scramble data deterministically",
    "title1_2c": "- To accept an input of arbitrary length and output a fixed-length result",
    "title1_2d": "- To manipulate data irreversibly",
    "title1_3": "The input cannot be derived from the output SHA-2 is a strong family of hash functions because, as you would expect, it serves all the purposes mentioned above.",
    "title2_1": "The input message is processed in blocks of 512 bits. If the message length is not a multiple of 512 bits, padding is added to the message to bring it to the appropriate length. The padding includes a \"1\" bit followed by a series of \"0\" bits, and the length of the original message is appended.",
    "title2_2": "The buffer is represented as eight 32-bit registers (A, B, C, D, E, F, G, H).",
    "title2_3": "The message is broken into 512 bits chunks, and each chunk goes through a complex process and 64 rounds of compression. The value obtained after each compression is added to the current hash value.",
    "title2_4": "The final hash value or digest is concatenated (linked together) based on all of the chunk values resulting from the processing step.",
    "title3_1": "SHA-2 is known for its security (it hasn't broken down like SHA-1) and its speed. In cases where keys are not generated, such as proof-of-work Bitcoin mining, a fast hash algorithm like SHA-2 often has the upper hand.",
    "title3_2a": "SHA-256 is useful in so many circumstances! It's a fast and secure hash function, here are some of the most common ways that it's used:",
    "title3_2b": "- To create website authentication schemes, using JWTs, HMACs and MACs",
    "title3_2c": "- To create digital signatures",
    "title3_2d": "- To secure blockchains like Bitcoin and Ethereum",
    "title3_2e": "- In anti-viruses, to compare the fingerprints of files and programs",
    "title3_2f": "- In version control systems like Git to check if data has changed",
    "title3_3": "After all, in SHA-256 there are 2^256 possible outputs."
  }
}
