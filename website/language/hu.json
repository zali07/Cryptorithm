{
  "base": {
    "crypt": "Crypt",
    "learning": "Tanuló",
    "logout": "Kilépés",
    "login": "Belépés",
    "submit": "Küldés",
    "welcomeTitle": "Üdvözöljük a Cryptorithm platformon!",
    "welcomeText1": "A Cryptorithm egy online kriptográfiai alkalmazás, amely lehetővé teszi a különböző kriptográfiai rendszerek kipróbálását és a kriptográfiával kapcsolatos tudás bővítését. Fedezze fel a titkosítás és visszafejtés izgalmas világát, és sajátítsa el a különféle kriptográfiai módszerek működését.",
    "welcomeText2": "Kattintson a \"Belépés\" gombra, hogy létrehozzon egy új profilt, vagy bejelentkezhessen egy már meglévőbe. Fedezze fel a rendelkezésre álló kriptográfiai eszközöket, kísérletezzen a különböző algoritmusokkal, és tapasztalja meg, hogyan változnak az adatok titkosítása és visszafejtése.",
    "welcomeText3": "Szeretne többet megtudni a kriptográfia világáról? Látogasson el a \"Tanuló\" szekcióba, ahol részletes információkat találhat a kriptográfiai rendszerek eredetéről, működéséről és felhasználási területeiről."
  },
  "cryptorithm": {
    "login": "Belépés",
    "email": "Email",
    "password": "Jelszó",
    "no_account": "Nincs még fiókod?",
    "signup": "Regisztráció",
    "password_confirm": "Jelszó megerősítése",
    "already_account": "Már van fiókod?"
  },
  "home": {
    "history": "Előzmények",
    "choose": "Válassz egy módszert:"
  },
  "learning": {
    "learn_about": "Tudj meg többet!",
    "list1": "Rejtjelezés",
    "list2": "Hash",
    "list3": "Blokk titkosítás"
  },
  "caesar": {
    "title1": "Caesar - Eredet",
    "title2": "Caesar - Leírás",
    "title3": "Caesar - Biztonság / Példa",
    "title1_1": "A Caesar rejtjelezés Julius Caesarról, az ókori római katonai és politikai vezetőről kapta a nevét, aki a feltételezések szerint ezt a titkosítási technikát használta. Neki tulajdonítják, bár valószínű, hogy hasonló technikákat már korábban is használtak. Julius Caesar a Caesar-féle rejtjelezést arra használta, hogy hadjáratai során védje az érzékeny katonai információkat. A betűk eltolása egyszerű és hatékony módot biztosított az üzenetek elrejtésére az ellenség elől, akik esetleg lehallgatná azokat.",
    "title1_2": "A módszer lényege, hogy az egyszerű szövegben minden egyes betűt meghatározott számú pozícióval eltolnak, Caesar a három pozícióval való eltolást preferálta. Például, ha az egyszerű szöveg \"ATTACK AT DAWN\", a Caesar-féle rejtjelezéssel előállított rejtjelezett szöveg \"DWWDFN DW GDZQ\".",
    "title2_1": "Minden betűt egyenként más betűvel titkosítunk, azaz a betűket egyenként helyettesítjük a hozzájuk rendelt betűkóddal, mindig ugyanazt a betűkódot rendelve egy betűhöz. Azt, hogy melyik betűt melyik betűvel helyettesítjük, a k kulcs határozza meg, amely az eredeti rendszerben egy egész szám. Egy betűt tehát mindig a betűtől k pozícióval jobbra lévő betűvel helyettesítünk, és feltételezzük, hogy a betűk körbe vannak rendezve, azaz az A betű ismét a Z betű után kerül.",
    "title2_2": "Matematikailag a következő képlet határozza meg, ahol a 'p' betű a numerikus kód, a 'k' betű az eltolási érték (kulcs) és 'c' a titkos numerikus kód:",
    "title2_3": "A visszafejtési képlet ennek a fordítottja, feltételezve, hogy a titkosított betű a 'c', akkor a matematikai képlet:",
    "title3_1": "A kulcs a Caesar-rejtjelezésben az, hogy az egyes betűket hány pozícióval toljuk el. Például a 3-as kulcs azt jelenti, hogy minden betű három pozícióval el van tolva az ábécében.",
    "title3_2": "Ez egy nagyon egyszerű és könnyen feltörhető kódolás. Mindössze 26 lehetséges kulcsa van, ami sebezhetővé teszi a nyers erővel végrehajtott támadásokkal szemben. Gyakran használják bevezető példaként a kriptográfiában, de gyakorlati célokra nem biztonságos."
  },
  "affin": {
    "title1": "Affin - Eredet",
    "title2": "Affin - Leírás",
    "title3": "Affin - Biztonság / Példa",
    "title1_1": "Az affin rejtjelezés gyökerei az ősi civilizációkban gyökereznek. Úgy vélik, hogy a rómaiak már az i. e. 1. század körül használták. Julius Caesar római katonai parancsnokot gyakran hozzák összefüggésbe az Affine rejtjelezés egy korai változatával, amelyet Caesar rejtjelezés vagy Caesar rejtjelezése néven ismernek.",
    "title1_2": "Az affin rejtjelezés koncepciója a Caesar-rejtjelezés általánosításaként később alakult ki. Az affin rejtjelezést fejlettebb kriptográfiai technikaként fejlesztették ki, amely a titkosítási lehetőségek szélesebb körét tette lehetővé.",
    "title2_1": "Az affin rejtjelezés az affin transzformáció matematikai fogalmán alapul. Az affin transzformáció egy olyan lineáris függvény, amely két műveletet kombinál: egy szorzást (moduláris aritmetika) és egy összeadást (modulo művelet).",
    "title2_2": "Az affin kódolásban használt paraméterek a titkosítási kulcs ('a') és a moduláris aritmetikai alap ('b'). Feltételezve, hogy 'p' a nyílt szövegben lévő betű numerikus kódja, és 'c' a titkosított numerikus kódnak megfelelője, a titkosítási képlet a következő:",
    "title2_3_1": "Ha",
    "title2_3_2": "az 'a' szám multiplikatív inverze a modulo 26 szerint, akkor a következő összefüggés érvényes:",
    "title2_4": "ekkor a megfejtési képlet a következő lesz:",
    "title3_1": "Idővel a kriptoanalitikusok olyan technikákat fejlesztettek ki, amelyekkel feltörhető az Affine rejtjelezés. Az algoritmus egyszerűsége és a korlátozott kulcstér miatt fogékony a nyers erővel végrehajtott támadásokra és a frekvenciaelemzési módszerekre.",
    "title3_2": "Bár az Affin rejtjelezés már nem tekinthető biztonságosnak a modern kriptográfiai célokra, még mindig tanulmányozzák és használják oktatási környezetben a titkosítás és dekódolás alapvető fogalmainak szemléltetésére. Bevezetésként szolgál a bonyolultabb kódok és kriptográfiai technikák megismeréséhez."
  },
  "aes": {
    "title1": "AES (Advanced Encryption Standard) - Eredet",
    "title2": "AES-CTR Leírás",
    "title3": "AES-CTR Biztonság / Példa",
    "title1_1": "Az AES, más néven Rijndael, egy szimmetrikus blokk titkosításó rendszer, amelyet a NIST 2001-ben szabványosított. A rendszert két belga kriptográfus, Vincent Rijmen és Joan Daemen fejlesztette ki, a Rijndael név a nevük rövidítése.",
    "title1_2": "A blokk titkosítások olyan titkosítási rendszerek, amelyekben a nyílt szöveg egy blokkját egyetlen blokkként kezelik, és egy azonos méretű rejtjelezett szövegblokk kinyerésére használják. Napjainkban az AES az egyik leggyakrabban használt algoritmus a blokktitkosításhoz. Az AES blokk mérete 128 bit, míg a titkosítási kulcs mérete 128, 192 vagy 256 bit lehet. Kérjük, vegye figyelembe, hogy a kulcsnak több hossza lehet, de a titkosítási blokk mérete mindig 128 bit.",
    "title1_3a": "Öt mód: ECB, CBC, CFB, OFB, CTR",
    "title1_3b": "Ebben az esetben a CTR (a számláló rövidítése) módot tárgyaljuk. Ennél a működési módnál a titkosító bemeneti blokkjaként, azaz IV-ként egy számláló (Counter, Counter + 1,..., Counter + N - 1) értéke kerül felhasználásra. Ez is egy folyamtitkosító.",
    "title1_4a": "Pros:",
    "title1_4b": "- Nincs kitöltés",
    "title1_4c": "- Támogatja a párhuzamos számítást",
    "title1_4d": "- A titkosítás és a visszafejtés ugyanazt a struktúrát használja",
    "title1_4e": "- A rossz blokk csak az aktuális blokkot érinti",
    "title1_4f": "Cons:",
    "title1_4g": "A MITM (Man in the Middle) megváltoztathatja a titkosított szöveg sérült egyszerű szövegét",
    "title2_1": "A titkos szimmetrikus kulcsot generálják vagy előre biztosítják. Az AES algoritmus ezt a kulcsot veszi, és kerek kulcsok halmazává bővíti, amelyeket a későbbi titkosítási folyamat során használnak.",
    "title2_2": "Az inicializáció vektor egy egyedi érték, amely a CTR módhoz szükséges. Az IV lehet véletlenszerűen generált vagy egy nonce (egyszer használt szám) és egy számlálóból származtatott. Az IV-nek minden titkosítási műveletnél egyedinek kell lennie a biztonság fenntartása érdekében. A számláló értéke az IV alapján inicializálódik. A számláló egy egyedi érték, amelyet minden egyes egyszerű vagy rejtjelezett szövegblokk esetében növelni kell.",
    "title2_3": "Az AES-CTR úgy működik, hogy a nyílt szöveget fix méretű blokkokra (pl. 128 bit) osztja. Minden egyes blokk esetében a számláló értéke az AES algoritmus és a kulcsbővítési fázisban generált körkulcsok segítségével titkosítva van. A számlálónak ez a titkosítása egy pszeudorandom kulcsfolyamot eredményez.",
    "title2_4": "A titkosítási lépésből generált pszeudorandom kulcsfolyamot ezután XOR-oljuk a megfelelő nyílt szövegű blokkal. Az XOR művelet eredménye a rejtjelezett szövegblokk. Ez a folyamat megismétlődik a nyílt szöveg minden egyes blokkjára, így keletkezik a teljes rejtjelezett szöveg.",
    "title2_5a": "Minden egyes titkosítási vagy visszafejtési művelet után a számláló értéke növekszik annak biztosítása érdekében, hogy minden blokkhoz egyedi értéket használjanak.",
    "title2_5b": "Ezzel az eljárással az AES-CTR az AES blokk titkosítást folyam titkosítássá alakítja át, és egy pszeudorandom kulcsfolyamot generál, amelyet az XOR művelet segítségével kombinálnak az egyszerű szöveggel vagy a rejtjelezett szöveggel.",
    "title3_1": "A biztonság érdekében a kulcsot ebben a módban 2^(n/2) titkosítási blokkonként kell megváltoztatni.",
    "title3_2a": "Támadási lehetőségek:",
    "title3_2b": "- PA (Padding Attack)",
    "title3_2c": "- CPA (Chose Plaintext Attack)",
    "title3_2d": "CCA (Choosen Ci)",
    "title3_3a": "Széles körben használatos:",
    "title3_3b": "- Hálózati kommunikáció",
    "title3_3c": "- Lemez- és fájltitkosítás",
    "title3_3d": "- Felhőalapú tárolás",
    "title3_3e": "- Valós idejű médiatitkosítás",
    "title3_3f": "- Vezeték nélküli biztonság"
  },
  "sha1": {
    "title1": "SHA-1 Eredet",
    "title2": "SHA-1 Leírás",
    "title3": "SHA-1 Biztonság",
    "title1_1a": "A SHA-1 (Secure Hash Algorithm 1) hash függvényt a ",
    "title1_1b": "Az SHA-1A egy bemeneti adatot kap, és egy 160 bites (20 bájtos) hash-értéket állít elő, amelyet üzenet digestként ismerünk - jellemzően 40 hexadecimális számjegy formájában. Az SHA-1 a létező SHA hash-funkciók közül a legelterjedtebb, és számos biztonsági alkalmazásban és protokollban használják. Az SHA-1 ütközésállósága azonban az új támadások felfedezésével vagy fejlesztésével egyre gyengül.",
    "title2_1": "A bemeneti üzenet 512 bites blokkokban kerül feldolgozásra. Ha az üzenet hossza nem 512 bit többszöröse, akkor az üzenethez tölteléket adunk hozzá, hogy a megfelelő hosszúságra hozzuk. A kitöltés egy \"1\" bitet tartalmaz, amelyet egy sor \"0\" bit követ, és az eredeti üzenet hossza hozzáadódik.",
    "title2_2a": "Ez az algoritmus két puffert és 32 bites szavak hosszú sorozatát igényli:",
    "title2_2b": "A két öt 32 bites regiszter (\"A, B, C, D, E\" és \"H0, H1, H2, H3, H4\") meghatározott kezdeti értékekkel rendelkezik, és a 80 32 bites szóból álló sorozat (W[0], W[1], W[2]... W[78], W[79]).",
    "title2_3": "Az SHA-1 algoritmus magja egy tömörítési függvény, amely egy 160 bites üzenettömbön és az üzenet digest aktuális állapotán dolgozik. Egy sor műveletet hajt végre, többek között bitenkénti logikai függvényeket, üzenetbővítést és moduláris összeadást.",
    "title2_4": "A tömörítési függvényt iteratív módon alkalmazza minden egyes üzenetblokkra, frissítve az üzenet digest állapotát minden egyes blokk feldolgozásakor. A végső kimenet a bemeneti üzenet hash-értéke.",
    "title2_5": "Minden egyes blokk egy összetett folyamaton megy keresztül, amely során egyenként 20 lépésből álló bővítésen és 80 tömörítési körön megy keresztül. Az egyes tömörítések után kapott érték hozzáadódik az aktuális pufferhez (hash állapot).",
    "title2_6": "Az így kapott hash-érték egy 160 bitből álló, rögzített méretű digest. Ez a bemeneti üzenet egyedi ujjlenyomatát jelenti, ami nagyon valószínűtlenné teszi, hogy két különböző üzenet ugyanazt a hash-értéket adja.",
    "title3_1": "Az SHA-1 egyik fő sebezhetősége a csökkent ütközésállósága. Az ütközés akkor következik be, amikor két különböző bemenet ugyanazt a hash-kimenetet eredményezi. 2005-ben kutatók bemutattak egy elméleti ütközési támadást az SHA-1 ellen, 2017-ben pedig sikeresen végrehajtottak egy tényleges ütközési támadást, ami rávilágított a gyakorlati biztonsági kockázatokra.",
    "title3_2": "Az azonosított sebezhetőségek miatt az SHA-1 elavultnak tekinthető, és nem ajánlott új kriptográfiai alkalmazásokban használni. Helyette erősebb hash függvények, mint az SHA-256 vagy magasabb tanúsítványok használata javasolt a nagyobb biztonság érdekében.",
    "title3_3a": "Használatos:",
    "title3_3b": "- Biztonsági alkalmazások és protokollok (pl. TLS, SSL, PGP, SSH, S/MIME, Ipsec).",
    "title3_3c": "- Kriptovaluta tranzakciók validálása",
    "title3_3d": "- Digitális tanúsítványok"
  },
  "sha2": {
    "title1": "SHA-2 Eredet",
    "title2": "SHA-2 Leírás",
    "title3": "SHA-2 Biztonság / Alkalmazások",
    "title1_1": "Az SHA-2 az SHA-1 utódja, amelyet a NIST jóváhagyott és ajánlott: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256. Az első négy ugyanazt a konstrukciót használja különböző kimeneti méretekkel, míg az utolsó kettő az SHA-512 csonka változata, ahol a kezdeti értékeket a\" pontban leírt módszerrel generálják.",
    "title1_2a": "A hash-függvények három fő célja:",
    "title1_2b": "- Az adatok determinisztikusan történő titkosítása",
    "title1_2c": "- Tetszőleges hosszúságú bemenetet fogad el, és fix hosszúságú eredményt ad ki",
    "title1_2d": "- Az adatok visszafordíthatatlan manipulálása",
    "title1_3": "A bemenet nem származtatható a kimenetből Az SHA-2 a hash-függvények erős családja, mivel - ahogyan az várható volt - a fent említett összes célt szolgálja.",
    "title2_1": "A bemeneti üzenet 512 bites blokkokban kerül feldolgozásra. Ha az üzenet hossza nem 512 bit többszöröse, akkor az üzenethez tölteléket adunk hozzá, hogy a megfelelő hosszúságra hozzuk. A kitöltés egy \"1\" bitet tartalmaz, amelyet egy \"0\" bit sorozat követ, és az eredeti üzenet hossza hozzáadódik.",
    "title2_2": "A puffert nyolc 32 bites regiszter (A, B, C, D, E, F, G, H) reprezentálja.",
    "title2_3": "Az üzenet 512 bites darabokra van bontva, és minden egyes darab egy összetett folyamaton és 64 körös tömörítésen megy keresztül. Az egyes tömörítések után kapott érték hozzáadódik az aktuális hash-értékhez.",
    "title2_4": "A végső hash-értéket vagy digestet a feldolgozási lépésből származó összes chunk-érték alapján konkatenálják (összekapcsolják).",
    "title3_1": "Az SHA-2 a biztonságáról (nem bomlott fel, mint az SHA-1) és a sebességéről ismert. Azokban az esetekben, amikor a kulcsokat nem generálják, például a proof-of-work Bitcoin-bányászatban, az olyan gyors hash-algoritmus, mint az SHA-2 gyakran előnyben van.",
    "title3_2a": "Az SHA-256 nagyon sok esetben hasznos! Ez egy gyors és biztonságos hash-függvény, íme néhány a leggyakoribb felhasználási módok közül:",
    "title3_2b": "- Webhely-hitelesítési sémák létrehozásához, JWT-k, HMAC-k és MAC-ek használatával",
    "title3_2c": "- Digitális aláírások létrehozására",
    "title3_2d": "- A Bitcoinhoz és az Ethereumhoz hasonló blokkláncok biztosításához",
    "title3_2e": "- A vírusirtókban a fájlok és programok ujjlenyomatainak összehasonlítására",
    "title3_2f": "- Az olyan verziókezelő rendszerekben, mint a Git, annak ellenőrzésére, hogy az adatok megváltoztak-e",
    "title3_3": "Végül is, az SHA-256-ban 2^256 (1.158 x 10^77) lehetséges kimenet van."
  }
}
