{
  "base": {
    "crypt": "Crypt",
    "learning": "Tanuló",
    "logout": "Kilépés",
    "login": "Belépés",
    "submit": "Küldés",
    "welcomeTitle": "Üdvözöljük a Cryptorithm platformon!",
    "welcomeText1": "A Cryptorithm egy online kriptográfiai alkalmazás, amely lehetővé teszi a különböző kriptográfiai rendszerek kipróbálását és a kriptográfiával kapcsolatos tudás bővítését. Fedezze fel a titkosítás és visszafejtés izgalmas világát, és sajátítsa el a különféle kriptográfiai módszerek működését.",
    "welcomeText2": "Kattintson a \"Belépés\" gombra, hogy létrehozzon egy új profilt, vagy bejelentkezhessen egy már meglévőbe. Fedezze fel a rendelkezésre álló kriptográfiai eszközöket, kísérletezzen a különböző algoritmusokkal, és tapasztalja meg, hogyan változnak az adatok titkosítása és visszafejtése.",
    "welcomeText3": "Szeretne többet megtudni a kriptográfia világáról? Látogasson el a \"Tanuló\" szekcióba, ahol részletes információkat találhat a kriptográfiai rendszerek eredetéről, működéséről és felhasználási területeiről."
  },
  "cryptorithm": {
    "login": "Belépés",
    "email": "Email",
    "password": "Jelszó",
    "no_account": "Nincs még fiókod?",
    "signup": "Regisztráció",
    "password_confirm": "Jelszó megerősítése",
    "already_account": "Már van fiókod?"
  },
  "home": {
    "history": "Előzmények",
    "choose": "Válassz egy módszert:"
  },
  "learning": {
    "learn_about": "Tudj meg többet!",
    "list1": "Rejtjelezés",
    "list2": "Hash",
    "list3": "Blokk titkosítás"
  },
  "caesar": {
    "title1": "Caesar - Eredet",
    "title2": "Caesar - Leírás",
    "title3": "Caesar - Biztonság / Példa",
    "title1_1": "A Caesar rejtjelezés Julius Caesarról, az ókori római katonai és politikai vezetőről kapta a nevét, aki a feltételezések szerint ezt a titkosítási technikát használta. Neki tulajdonítják, bár valószínű, hogy hasonló technikákat már korábban is használtak. Julius Caesar a Caesar-féle rejtjelezést arra használta, hogy hadjáratai során védje az érzékeny katonai információkat. A betűk eltolása egyszerű és hatékony módot biztosított az üzenetek elrejtésére az ellenség elől, akik esetleg lehallgatná azokat.",
    "title1_2": "A módszer lényege, hogy az egyszerű szövegben minden egyes betűt meghatározott számú pozícióval eltolnak, Caesar a három pozícióval való eltolást preferálta. Például, ha az egyszerű szöveg \"ATTACK AT DAWN\", a Caesar-féle rejtjelezéssel előállított rejtjelezett szöveg \"DWWDFN DW GDZQ\".",
    "title2_1": "Minden betűt egyenként más betűvel titkosítunk, azaz a betűket egyenként helyettesítjük a hozzájuk rendelt betűkóddal, mindig ugyanazt a betűkódot rendelve egy betűhöz. Azt, hogy melyik betűt melyik betűvel helyettesítjük, a k kulcs határozza meg, amely az eredeti rendszerben egy egész szám. Egy betűt tehát mindig a betűtől k pozícióval jobbra lévő betűvel helyettesítünk, és feltételezzük, hogy a betűk körbe vannak rendezve, azaz az A betű ismét a Z betű után kerül.",
    "title2_2": "Matematikailag a következő képlet határozza meg, ahol a 'p' betű a numerikus kód, a 'k' betű az eltolási érték (kulcs) és 'c' a titkos numerikus kód:",
    "title2_3": "A visszafejtési képlet ennek a fordítottja, feltételezve, hogy a titkosított betű a 'c', akkor a matematikai képlet:",
    "title3_1": "A kulcs a Caesar-rejtjelezésben az, hogy az egyes betűket hány pozícióval toljuk el. Például a 3-as kulcs azt jelenti, hogy minden betű három pozícióval el van tolva az ábécében.",
    "title3_2": "Ez egy nagyon egyszerű és könnyen feltörhető kódolás. Mindössze 26 lehetséges kulcsa van, ami sebezhetővé teszi a nyers erővel végrehajtott támadásokkal szemben. Gyakran használják bevezető példaként a kriptográfiában, de gyakorlati célokra nem biztonságos."
  },
  "affin": {
    "title1": "Affin - Eredet",
    "title2": "Affin - Leírás",
    "title3": "Affin - Biztonság / Példa",
    "title1_1": "Az affin rejtjelezés gyökerei az ősi civilizációkban gyökereznek. Úgy vélik, hogy a rómaiak már az i. e. 1. század körül használták. Julius Caesar római katonai parancsnokot gyakran hozzák összefüggésbe az Affine rejtjelezés egy korai változatával, amelyet Caesar rejtjelezés vagy Caesar rejtjelezése néven ismernek.",
    "title1_2": "Az affin rejtjelezés koncepciója a Caesar-rejtjelezés általánosításaként később alakult ki. Az affin rejtjelezést fejlettebb kriptográfiai technikaként fejlesztették ki, amely a titkosítási lehetőségek szélesebb körét tette lehetővé.",
    "title2_1": "Az affin rejtjelezés az affin transzformáció matematikai fogalmán alapul. Az affin transzformáció egy olyan lineáris függvény, amely két műveletet kombinál: egy szorzást (moduláris aritmetika) és egy összeadást (modulo művelet).",
    "title2_2": "Az affin kódolásban használt paraméterek a titkosítási kulcs ('a') és a moduláris aritmetikai alap ('b'). Feltételezve, hogy 'p' a nyílt szövegben lévő betű numerikus kódja, és 'c' a titkosított numerikus kódnak megfelelője, a titkosítási képlet a következő:",
    "title2_3_1": "Ha",
    "title2_3_2": "az 'a' szám multiplikatív inverze a modulo 26 szerint, akkor a következő összefüggés érvényes:",
    "title2_4": "ekkor a megfejtési képlet a következő lesz:",
    "title3_1": "Idővel a kriptoanalitikusok olyan technikákat fejlesztettek ki, amelyekkel feltörhető az Affine rejtjelezés. Az algoritmus egyszerűsége és a korlátozott kulcstér miatt fogékony a nyers erővel végrehajtott támadásokra és a frekvenciaelemzési módszerekre.",
    "title3_2": "Bár az Affin rejtjelezés már nem tekinthető biztonságosnak a modern kriptográfiai célokra, még mindig tanulmányozzák és használják oktatási környezetben a titkosítás és dekódolás alapvető fogalmainak szemléltetésére. Bevezetésként szolgál a bonyolultabb kódok és kriptográfiai technikák megismeréséhez."
  },
  "aes": {
    "title1": "AES (Advanced Encryption Standard) - Eredet",
    "title2": "AES-CTR Leírás",
    "title3": "AES-CTR Biztonság / Példa",
    "title1_1": "Az AES, más néven Rijndael, egy szimmetrikus blokk titkosításó rendszer, amelyet a NIST 2001-ben szabványosított. A rendszert két belga kriptográfus, Vincent Rijmen és Joan Daemen fejlesztette ki, a Rijndael név a nevük rövidítése.",
    "title1_2": "A blokk titkosítások olyan titkosítási rendszerek, amelyekben a nyílt szöveg egy blokkját egyetlen blokkként kezelik, és egy azonos méretű rejtjelezett szövegblokk kinyerésére használják. Napjainkban az AES az egyik leggyakrabban használt algoritmus a blokktitkosításhoz. Az AES blokk mérete 128 bit, míg a titkosítási kulcs mérete 128, 192 vagy 256 bit lehet. Kérjük, vegye figyelembe, hogy a kulcsnak több hossza lehet, de a titkosítási blokk mérete mindig 128 bit.",
    "title1_3a": "Öt mód: ECB, CBC, CFB, OFB, CTR",
    "title1_3b": "Ebben az esetben a CTR (a számláló rövidítése) módot tárgyaljuk. Ennél a működési módnál a titkosító bemeneti blokkjaként, azaz IV-ként egy számláló (Counter, Counter + 1,..., Counter + N - 1) értéke kerül felhasználásra. Ez is egy folyamtitkosító.",
    "title1_4a": "Pros:",
    "title1_4b": "- Nincs kitöltés",
    "title1_4c": "- Támogatja a párhuzamos számítást",
    "title1_4d": "- A titkosítás és a visszafejtés ugyanazt a struktúrát használja",
    "title1_4e": "- A rossz blokk csak az aktuális blokkot érinti",
    "title1_4f": "Cons:",
    "title1_4g": "A MITM (Man in the Middle) megváltoztathatja a titkosított szöveg sérült egyszerű szövegét",
    "title2_1": "A titkos szimmetrikus kulcsot generálják vagy előre biztosítják. Az AES algoritmus ezt a kulcsot veszi, és kerek kulcsok halmazává bővíti, amelyeket a későbbi titkosítási folyamat során használnak.",
    "title2_2": "Az inicializáció vektor egy egyedi érték, amely a CTR módhoz szükséges. Az IV lehet véletlenszerűen generált vagy egy nonce (egyszer használt szám) és egy számlálóból származtatott. Az IV-nek minden titkosítási műveletnél egyedinek kell lennie a biztonság fenntartása érdekében. A számláló értéke az IV alapján inicializálódik. A számláló egy egyedi érték, amelyet minden egyes egyszerű vagy rejtjelezett szövegblokk esetében növelni kell.",
    "title2_3": "Az AES-CTR úgy működik, hogy a nyílt szöveget fix méretű blokkokra (pl. 128 bit) osztja. Minden egyes blokk esetében a számláló értéke az AES algoritmus és a kulcsbővítési fázisban generált körkulcsok segítségével titkosítva van. A számlálónak ez a titkosítása egy pszeudorandom kulcsfolyamot eredményez.",
    "title2_4": "A titkosítási lépésből generált pszeudorandom kulcsfolyamot ezután XOR-oljuk a megfelelő nyílt szövegű blokkal. Az XOR művelet eredménye a rejtjelezett szövegblokk. Ez a folyamat megismétlődik a nyílt szöveg minden egyes blokkjára, így keletkezik a teljes rejtjelezett szöveg.",
    "title2_5a": "Minden egyes titkosítási vagy visszafejtési művelet után a számláló értéke növekszik annak biztosítása érdekében, hogy minden blokkhoz egyedi értéket használjanak.",
    "title2_5b": "Ezzel az eljárással az AES-CTR az AES blokk titkosítást folyam titkosítássá alakítja át, és egy pszeudorandom kulcsfolyamot generál, amelyet az XOR művelet segítségével kombinálnak az egyszerű szöveggel vagy a rejtjelezett szöveggel.",
    "title3_1": "A biztonság érdekében a kulcsot ebben a módban 2^(n/2) titkosítási blokkonként kell megváltoztatni.",
    "title3_2a": "Támadási lehetőségek:",
    "title3_2b": "- PA (Padding Attack)",
    "title3_2c": "- CPA (Chose Plaintext Attack)",
    "title3_2d": "CCA (Choosen Ci)",
    "title3_3a": "Széles körben használatos:",
    "title3_3b": "- Hálózati kommunikáció",
    "title3_3c": "- Lemez- és fájltitkosítás",
    "title3_3d": "- Felhőalapú tárolás",
    "title3_3e": "- Valós idejű médiatitkosítás",
    "title3_3f": "- Vezeték nélküli biztonság"
  },
  "sha1": {
    "title1": "SHA-1 Eredet",
    "title2": "SHA-1 Leírás",
    "title3": "SHA-1 Biztonság",
    "title1_1a": "A SHA-1 (Secure Hash Algorithm 1) hash függvényt a ",
    "title1_1b": "Az SHA-1A egy bemeneti adatot kap, és egy 160 bites (20 bájtos) hash-értéket állít elő, amelyet üzenet digestként ismerünk - jellemzően 40 hexadecimális számjegy formájában. Az SHA-1 a létező SHA hash-funkciók közül a legelterjedtebb, és számos biztonsági alkalmazásban és protokollban használják. Az SHA-1 ütközésállósága azonban az új támadások felfedezésével vagy fejlesztésével egyre gyengül.",
    "title2_1": "A bemeneti üzenet 512 bites blokkokban kerül feldolgozásra. Ha az üzenet hossza nem 512 bit többszöröse, akkor az üzenethez tölteléket adunk hozzá, hogy a megfelelő hosszúságra hozzuk. A kitöltés egy \"1\" bitet tartalmaz, amelyet egy sor \"0\" bit követ, és az eredeti üzenet hossza hozzáadódik.",
    "title2_2a": "Ez az algoritmus két puffert és 32 bites szavak hosszú sorozatát igényli:",
    "title2_2b": "A két öt 32 bites regiszter (\"A, B, C, D, E\" és \"H0, H1, H2, H3, H4\") meghatározott kezdeti értékekkel rendelkezik, és a 80 32 bites szóból álló sorozat (W[0], W[1], W[2]... W[78], W[79]).",
    "title2_3": "Az SHA-1 algoritmus magja egy tömörítési függvény, amely egy 160 bites üzenettömbön és az üzenet digest aktuális állapotán dolgozik. Egy sor műveletet hajt végre, többek között bitenkénti logikai függvényeket, üzenetbővítést és moduláris összeadást.",
    "title2_4": "A tömörítési függvényt iteratív módon alkalmazza minden egyes üzenetblokkra, frissítve az üzenet digest állapotát minden egyes blokk feldolgozásakor. A végső kimenet a bemeneti üzenet hash-értéke.",
    "title2_5": "Minden egyes blokk egy összetett folyamaton megy keresztül, amely során egyenként 20 lépésből álló bővítésen és 80 tömörítési körön megy keresztül. Az egyes tömörítések után kapott érték hozzáadódik az aktuális pufferhez (hash állapot).",
    "title2_6": "Az így kapott hash-érték egy 160 bitből álló, rögzített méretű digest. Ez a bemeneti üzenet egyedi ujjlenyomatát jelenti, ami nagyon valószínűtlenné teszi, hogy két különböző üzenet ugyanazt a hash-értéket adja.",
    "title3_1": "Az SHA-1 egyik fő sebezhetősége a csökkent ütközésállósága. Az ütközés akkor következik be, amikor két különböző bemenet ugyanazt a hash-kimenetet eredményezi. 2005-ben kutatók bemutattak egy elméleti ütközési támadást az SHA-1 ellen, 2017-ben pedig sikeresen végrehajtottak egy tényleges ütközési támadást, ami rávilágított a gyakorlati biztonsági kockázatokra.",
    "title3_2": "Az azonosított sebezhetőségek miatt az SHA-1 elavultnak tekinthető, és nem ajánlott új kriptográfiai alkalmazásokban használni. Helyette erősebb hash függvények, mint az SHA-256 vagy magasabb tanúsítványok használata javasolt a nagyobb biztonság érdekében.",
    "title3_3a": "Használatos:",
    "title3_3b": "- Biztonsági alkalmazások és protokollok (pl. TLS, SSL, PGP, SSH, S/MIME, Ipsec).",
    "title3_3c": "- Kriptovaluta tranzakciók validálása",
    "title3_3d": "- Digitális tanúsítványok"
  },
  "sha2": {
    "title1": "SHA-2 Eredet",
    "title2": "SHA-2 Leírás",
    "title3": "SHA-2 Biztonság / Alkalmazások",
    "title1_1": "Az SHA-2 az SHA-1 utódja, amelyet a NIST jóváhagyott és ajánlott: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256. Az első négy ugyanazt a konstrukciót használja különböző kimeneti méretekkel, míg az utolsó kettő az SHA-512 csonka változata, ahol a kezdeti értékeket a\" pontban leírt módszerrel generálják.",
    "title1_2a": "A hash-függvények három fő célja:",
    "title1_2b": "- Az adatok determinisztikusan történő titkosítása",
    "title1_2c": "- Tetszőleges hosszúságú bemenetet fogad el, és fix hosszúságú eredményt ad ki",
    "title1_2d": "- Az adatok visszafordíthatatlan manipulálása",
    "title1_3": "A bemenet nem származtatható a kimenetből Az SHA-2 a hash-függvények erős családja, mivel - ahogyan az várható volt - a fent említett összes célt szolgálja.",
    "title2_1": "A bemeneti üzenet 512 bites blokkokban kerül feldolgozásra. Ha az üzenet hossza nem 512 bit többszöröse, akkor az üzenethez tölteléket adunk hozzá, hogy a megfelelő hosszúságra hozzuk. A kitöltés egy \"1\" bitet tartalmaz, amelyet egy \"0\" bit sorozat követ, és az eredeti üzenet hossza hozzáadódik.",
    "title2_2": "A puffert nyolc 32 bites regiszter (A, B, C, D, E, F, G, H) reprezentálja.",
    "title2_3": "Az üzenet 512 bites darabokra van bontva, és minden egyes darab egy összetett folyamaton és 64 körös tömörítésen megy keresztül. Az egyes tömörítések után kapott érték hozzáadódik az aktuális hash-értékhez.",
    "title2_4": "A végső hash-értéket vagy digestet a feldolgozási lépésből származó összes chunk-érték alapján konkatenálják (összekapcsolják).",
    "title3_1": "Az SHA-2 a biztonságáról (nem bomlott fel, mint az SHA-1) és a sebességéről ismert. Azokban az esetekben, amikor a kulcsokat nem generálják, például a proof-of-work Bitcoin-bányászatban, az olyan gyors hash-algoritmus, mint az SHA-2 gyakran előnyben van.",
    "title3_2a": "Az SHA-256 nagyon sok esetben hasznos! Ez egy gyors és biztonságos hash-függvény, íme néhány a leggyakoribb felhasználási módok közül:",
    "title3_2b": "- Webhely-hitelesítési sémák létrehozásához, JWT-k, HMAC-k és MAC-ek használatával",
    "title3_2c": "- Digitális aláírások létrehozására",
    "title3_2d": "- A Bitcoinhoz és az Ethereumhoz hasonló blokkláncok biztosításához",
    "title3_2e": "- A vírusirtókban a fájlok és programok ujjlenyomatainak összehasonlítására",
    "title3_2f": "- Az olyan verziókezelő rendszerekben, mint a Git, annak ellenőrzésére, hogy az adatok megváltoztak-e",
    "title3_3": "Végül is, az SHA-256-ban 2^256 (1.158 x 10^77) lehetséges kimenet van."
  },
  "chacha": {
    "title1": "ChaCha Eredet",
    "title2": "ChaCha Leírás",
    "title3": "ChaCha Biztonság / Alkalmazások",
    "title1_1": "A ChaCha20 egy szimmetrikus kulcsú folyamtitkosítási algoritmus, amelyet Daniel J. Bernstein tervezett. A tervezési folyamat során Bernstein a Salsa20 algoritmust alakította át, hogy még hatékonyabbá és biztonságosabbá tegye. A ChaCha20 népszerűvé vált a biztonságos kommunikációban, különösen a Transport Layer Security (TLS) protokollban.",
    "title2_1": "A ChaCha20 működése a következő lépésekben valósul meg:",
    "title2_2": "Kulcs és iv inicializálása: A titkosítás előtt a ChaCha20-hoz egy 256 bites kulcsot és egy 64 bites kezdőértéket, azaz iv-t (initialization vector) kell generálni.",
    "title2_3": "Blokkok generálása: A ChaCha20 a kulcs és az iv segítségével generál egy sorozatot 512 bites blokkokból. A blokkokat egy belső állapotmátrix segítségével hozza létre.",
    "title2_4": "Titkosítás: Az eredeti adatokat blokkokra osztják, majd ezeket az adatblokkokat az előző lépésben generált blokkokkal exkluzív VAGY művelettel kombinálják. Ez a lépés a titkosítást végzi.",
    "title2_5": "Eredmény kimenetele: A titkosított adatblokkokat összefűzik, és a végkimenetet kapjuk.",
    "title3_1": "A ChaCha20 algoritmus gyors és hatékony titkosítást biztosít, és ellenálló a legtöbb ismert támadás típussal szemben. Ezért egy népszerű és megbízható választás a biztonságos kommunikációban és adatvédelemben. A ChaCha20 jelenleg sok alkalmazásban és protokollban használatos a titkosítás és hitelesítés terén. Néhány példa a következő:",
    "title3_2": "TLS 1.3: A ChaCha20-Poly1305 kombinációja az egyik kiválasztott titkosítási algoritmus a TLS 1.3-ban, amely biztosítja a weboldalak és a felhasználók közötti biztonságos kapcsolatot. Ez a kombináció hatékony és biztonságos titkosítást és hitelesítést biztosít.",
    "title3_3": "IPsec: Az IPsec (Internet Protocol Security) protokollban is használható a ChaCha20 a virtuális magánhálózatok (VPN) kialakításához. Az IPsec segítségével biztonságos adatátvitel valósítható meg hálózatok között.",
    "title3_4": "Messaging alkalmazások: Néhány biztonságos üzenetküldő alkalmazás, például a Signal és a WhatsApp, a ChaCha20 algoritmust használja a végpontok közötti titkosításra. Ez lehetővé teszi a felhasználóknak, hogy bizalmas üzeneteket küldjenek és fogadjanak, megőrizve az adatok biztonságát.",
    "title3_5": "Internet Engineering Task Force (IETF) protokollok: A ChaCha20-Poly1305 algoritmus széles körben alkalmazott az IETF által elfogadott protokollokban, például a Datagram Transport Layer Security (DTLS) és a Secure Real-time Transport Protocol (SRTP) esetén."
  },
  "blowfish": {
    "title1": "Blowfish Eredet",
    "title2": "Blowfish Leírás",
    "title3": "Blowfish Biztonság / Alkalmazások",
    "title1_1": "A Blowfish egy blokktitkosítási algoritmus, amelyet Bruce Schneier tervezett 1993-ban. Az algoritmus tervezésekor Schneier arra törekedett, hogy egy hatékony és biztonságos titkosítási rendszert hozzon létre. A Blowfish algoritmus hosszú ideig népszerű és széles körben használt volt, bár ma már kevésbé elterjedt.",
    "title2_1": "Most tekintsünk részletesebben a Blowfish működésére:",
    "title2_2": "Kulcs kiterjesztése: A Blowfish kezdeti állapotát a kulcs segítségével állítja be. A kulcs hossza lehet 32-448 bit között.",
    "title2_3": "Blokkok osztása és iterációk: A bemeneti adatokat 64 bites blokkokra osztják, majd az algoritmus többször végrehajtja az ún. iterációkat. Minden iteráció során a blokkokat a kulcs speciális részeivel kombinálják.",
    "title2_4": "F-érték kiszámítása: Az iterációk során kiszámítják az F-függvény értékét. Ez a függvény a Blox függvényt használja, amely kombinálja a bemenet és a kulcs részeit.",
    "title2_5": "Titkosítás és dekódolás: Az iterációk végén a blokkok a végleges állapotba kerülnek, és ez a kimeneti titkosított adat vagy a dekódolt eredeti adat.",
    "title3_1": "A Blowfish működése során az iterációk száma határozza meg az algoritmus biztonsági szintjét. Minél több iterációt használnak, annál biztonságosabbá válik a titkosítás, de ez hatással lehet a teljesítményre is.",
    "title3_2": "Fontos megjegyezni, hogy a Blowfish algoritmus a hatékony és biztonságos titkosítás terén népszerű volt, de azóta biztonsági kérdések és újabb algoritmusok megjelenése miatt a legújabb ajánlásokban már kevésbé szerepel. Az Advanced Encryption Standard (AES) ma általánosan elfogadott és széles körben használt blokktitkosítási algoritmus.",
    "title3_3": "A Blowfish jelenleg is néhány alkalmazásban használatos, például:",
    "title3_4": "Adatbázis titkosítás: A Blowfishet néha alkalmazzák adatbázisrendszerekben a tárolt adatok védelmére. Például a MySQL adatbázisrendszerekben a Blowfish titkosítást lehet alkalmazni a tárolt adatok védelmére.",
    "title3_5": "Fájltitkosítás: A Blowfish algoritmust lehet alkalmazni fájlok titkosítására is. Ez lehetővé teszi a felhasználók számára, hogy bizalmas fájlokat védenek a hozzáférés elől.",
    "title3_6": "Virtual Private Network (VPN): Néhány VPN szolgáltatás még mindig használja a Blowfish titkosítási algoritmust a biztonságos adatátvitelhez. Bár az AES (Advanced Encryption Standard) népszerűbbé vált, a Blowfish továbbra is támogatott lehetőség marad bizonyos VPN-k esetében."
  },
  "whirlpool": {
    "title1": "Whirlpool Eredet",
    "title2": "Whirlpool Leírás",
    "title3": "Whirlpool Biztonság / Alkalmazások",
    "title1_1": "A Whirlpool egy hash-függvény, amelyet Vincent Rijmen és Paulo S. L. M. Barreto tervezett. A tervezési folyamat során céljuk egy biztonságos és hatékony hash-algoritmus létrehozása volt. A Whirlpool 2000-ben vált nemzetközileg elfogadott standarddá.",
    "title2_1": "Most tekintsünk részletesebben a Whirlpool működésére:",
    "title2_2": "Bemenet előkészítése: A bemeneti adatokat először kiegészítik, hogy megfeleljenek a blokkméretnek.",
    "title2_3": "Bemeneti blokkok feldolgozása: A bemenetet blokkokra osztják, majd ezeket a blokkokat feldolgozzák a Whirlpool belső állapotában.",
    "title2_4": "Permutáció és helyettesítés: A blokkokat a permutációs és helyettesítési fázis során többször kombinálják. Ez magában foglalja a mátrix helyettesítését, a bitcserét és a bitenkénti exkluzív VAGY műveleteket.",
    "title2_5": "Kibővítés és összeadás: A feldolgozott blokkokat a belső állapotmátrixhoz hozzáadják, majd a kibővített és összeadott értéket kapjuk.",
    "title2_6": "Végeredmény kimenetele: A feldolgozás során keletkező végső értékeket összeadják, és ez a Whirlpool hash-értékének kimenete.",
    "title3_1": "A Whirlpool hash-függvény nagy biztonságot és ellenállást nyújt a kriptoanalitikai támadásokkal szemben. Alkalmazása során figyelembe kell venni a bemeneti adatok előkészítését és a hash-érték hosszát a konkrét alkalmazáshoz igazítva.",
    "title3_2": "Fontos megjegyezni, hogy a Whirlpool hash-függvény egy régebbi algoritmus, és jelenleg a SHA-3 (Secure Hash Algorithm 3) hash-függvény ajánlott a legfrissebb biztonsági követelményeknek való megfeleléshez.",
    "title3_3": "A Whirlpool jelenleg is használatban van több különböző területen, például:",
    "title3_4": "Digitális aláírások: A Whirlpool hash-függvényt alkalmazzák digitális aláírások létrehozásához. Segít az adatok integritásának ellenőrzésében és a digitális aláírások biztonságában.",
    "title3_5": "Jelszó tárolás: A Whirlpool hash-függvényt néha használják jelszavak tárolásához. A jelszavakat először a hash-függvénnyel alakítják át, majd a hash-értéket tárolják a rendszerben. Ez biztonságosabbá teszi a jelszavak tárolását, mivel a hash-érték alapján nem lehet visszafejteni a jelszót."
  }
}
