{
  "base": {
    "crypt": "Crypt",
    "learning": "Learning",
    "logout": "Logout",
    "login": "Login",
    "submit": "Submit",
    "welcomeTitle": "Welcome at Cryptorithm!",
    "welcomeText1": "Cryptorithm is an online cryptography application that allows you to try out different cryptographic systems and increase your knowledge of cryptography. Explore the exciting world of encryption and decryption and learn how different cryptographic methods work.",
    "welcomeText2": "Click on the \"Login\" button to create a new profile or log in to an existing one. Explore the cryptographic tools available, experiment with different algorithms, and see how data encryption and decryption are changing.",
    "welcomeText3": "Want to know more about the world of cryptography? Visit the \"Learning\" section where you will find detailed information on the origins, operation and uses of cryptographic systems."
  },
  "cryptorithm": {
    "login": "Login",
    "email": "Email",
    "password": "Password",
    "no_account": "Don't have an account?",
    "signup": "Sign Up",
    "password_confirm": "Password (Confirm)",
    "already_account": "Already have an account?"
  },
  "home": {
    "history": "History",
    "choose": "Choose an algortihm: ",
    "submit": "Submit",
    "placeholder": "Enter your text here...",
    "none": "None"
  },
  "learning": {
    "learn_about": "Learn about!",
    "list1": "Basics",
    "list2": "Stream Cipher",
    "list3": "Hash",
    "list4": "Block Cipher",
    "next": "Next",
    "previous": "Previous"
  },
  "caesar": {
    "title1": "Caesar - Origin",
    "title2": "Caesar - Description",
    "title3": "Caesar - Key / Security",
    "title1_1": "The Caesar cipher is named after Julius Caesar, the ancient Roman military and political leader who is believed to have used this encryption technique. The cipher is attributed to him, although it is likely that similar techniques were used even earlier. Julius Caesar used the Caesar cipher to protect sensitive military information during his campaigns. The shift of letters provided a simple and effective way to conceal messages from enemies who might intercept them.",
    "title1_2": "The method involves shifting each letter in the plaintext by a fixed number of positions, with Caesar's preferred shift being three positions. For example, if the plaintext is \"ATTACK AT DAWN\", the ciphertext generated using Caesar's cipher is \"DWWDFN DW GDZQ\".",
    "title2_1": "Each letter is encrypted one by one with a different letter, i.e. the letters are replaced one by one by the letter code assigned to them, always assigning the same letter code to a letter. Which letter is replaced by which letter is determined by the key k, which is an integer in the original system. A letter will thus always be replaced by a letter k positions to the right of the letter, and it is assumed that the letters are arranged in a circle, i.e. the letter A is again placed after the letter Z.",
    "title2_2": "Mathematically, it is defined by the following formula, where the letter p is the numeric code, the letter k is the offset value (key) and c is the secret numeric code:",
    "title2_3": "The decryption formula is the inverse of this, assuming that the encrypted letter is c, then the mathematical formula is:",
    "title3_1": "The key in the Caesar cipher is the number of positions each letter is shifted. For example, a key of 3 means each letter is shifted three positions down the alphabet.",
    "title3_2": "The Caesar cipher is a very basic and easily breakable cipher. It has only 26 possible keys, making it vulnerable to brute-force attacks. It is often used as an introductory example in cryptography, but it is not secure for practical purposes."
  },
  "affin": {
    "title1": "Affin - Origin",
    "title2": "Affin - Description",
    "title3": "Affin - Security / Example",
    "title1_1": "The Affine cipher has its roots in ancient civilizations. It is believed to have been used by the Romans around the 1st century BC. The Roman military commander Julius Caesar is often associated with an early version of the Affine cipher, known as the Caesar cipher or Caesar's cipher.",
    "title1_2": "The concept of the Affine cipher as a generalization of the Caesar cipher emerged later. The Affine cipher was developed as a more advanced cryptographic technique that allowed for a wider range of encryption possibilities.",
    "title2_1": "The Affine cipher is based on the mathematical concept of an affine transformation. An affine transformation is a linear function that combines two operations: a multiplication (modular arithmetic) and an addition (modulo operation).",
    "title2_2": "The parameters used in the Affine cipher are the encryption key ('a') and the modular arithmetic base ('b'). Assuming that 'p' is the numerical code of a letter in the plaintext and 'c' is its corresponding to the encrypted numeric code, the encryption formula is as follows:",
    "title2_3a": "If the",
    "title2_3b": "is the multiplicative inverse of the number 'a' according to 26, i.e the following relation holds:",
    "title2_4": "then the decryption formula will be:",
    "title3_1": "Over time, cryptanalysts have developed techniques to break the Affine cipher. The simplicity of the algorithm and the limited key space make it susceptible to brute-force attacks and frequency analysis methods.",
    "title3_2": "Although the Affine cipher is no longer considered secure for modern cryptographic purposes, it is still studied and used in educational settings to illustrate fundamental concepts of encryption and decryption. It serves as an introduction to more complex ciphers and cryptographic techniques."
  },
  "aes": {
    "title1": "AES Origin",
    "title2": "AES-CTR Description",
    "title3": "AES-CTR Security",
    "title1_1": "AES (Advanced Encryption Standard), also known as Rijndael, is a symmetric block cipher cryptosystem, which was standardized by the NIST in 2001. The system was developed by two Belgian cryptographers, Vincent Rijmen and Joan Daemen, and the name Rijndael is a contraction of their names.",
    "title1_2": "The block ciphers are schemes for encryption or decryption where a block of plaintext is treated as a single block and is used to obtain a block of ciphertext with the same size. Today, AES is one of the most used algorithms for block encryption. The size of an AES block is 128 bits, whereas the size of the encryption key can be 128, 192 or 256 bits. Please note this, there is three length in the key, but the size of the encryption block always is 128 bits.",
    "title1_3a": "Five modes: ECB, CBC, CFB, OFB, CTR",
    "title1_3b": "In this case we are discussing the CTR (short for counter) mode. At this mode of operation as an input block to the encryptor, i.e. as an IV, the value of a counter (Counter, Counter + 1,…, Counter + N - 1) is used. It also is a stream encryptor.",
    "title1_4a": "Pros:",
    "title1_4b": "- No padding",
    "title1_4c": "- Supports parallel computing",
    "title1_4d": "- Encryption and decryption use the same structure",
    "title1_4e": "- Bad block only affect the current block",
    "title1_4f": "Cons:",
    "title1_4g": "- A MITM (Man in the Middle) can change some ciphertext damaged plaintext",
    "title2_1": "A secret symmetric key is generated or provided. The AES algorithm takes this key and expands it into a set of round keys that will be used in the subsequent encryption process.",
    "title2_2": "An Initialization Vector is a unique value that is required for the CTR mode. The IV can be generated randomly or derived from a nonce (number used once) and a counter. The IV should be unique for each encryption operation to maintain security. The counter value is initialized based on the IV. The counter is a unique value that is incremented for each block of plaintext or ciphertext.",
    "title2_3": "AES-CTR operates by dividing the plaintext into fixed-size blocks (e.g., 128 bits). For each block, the counter value is encrypted using the AES algorithm and the round keys generated in the key expansion phase. This encryption of the counter produces a pseudorandom keystream.",
    "title2_4": "The pseudorandom keystream generated from the encryption step is then XORed with the corresponding plaintext block. The result of the XOR operation is the ciphertext block. This process is repeated for each block of plaintext, generating the complete ciphertext.",
    "title2_5a": "After each encryption or decryption operation, the counter value is incremented to ensure that a unique value is used for each block.",
    "title2_5b": "By using this process, AES-CTR transforms the AES block cipher into a stream cipher, generating a pseudorandom keystream that is combined with the plaintext or ciphertext through the XOR operation.",
    "title3_1": "To ensure security, the key in this mode need to be changed for every 2^(n/2) encryption blocks.",
    "title3_2a": "Attack modes:",
    "title3_2b": "- PA (Padding Attack)",
    "title3_2c": "- CPA (Chose Plaintext Attack)",
    "title3_2d": "- CCA (Choosen Ci)",
    "title3_3a": "It's commonly used in:",
    "title3_3b": "- Network Communication",
    "title3_3c": "- Disk and File Encryption",
    "title3_3d": "- Cloud Storage",
    "title3_3e": "- Real-Time Media Encryption",
    "title3_3f": "- Wireless Security"
  },
  "sha1": {
    "title1": "SHA-1 Origin",
    "title2": "SHA-1 Description",
    "title3": "SHA-1 Security",
    "title1_1a": "The SHA-1 (Secure Hash Algorithm 1) hash function, designed by the ",
    "title1_1b": "takes an input and produces a 160-bit (20-byte) hash value known as a message digest - typically rendered as 40 hexadecimal digits. SHA-1 is the most established of the existing SHA hash functions and it is used in a variety of security applications and protocols. However, SHA-1's collision resistance has been weakening as new attacks are discovered or improved.",
    "title2_1": "The input message is processed in blocks of 512 bits. If the message length is not a multiple of 512 bits, padding is added to the message to bring it to the appropriate length. The padding includes a \"1\" bit followed by a series of \"0\" bits, and the length of the original message is appended.",
    "title2_2a": "This algorithm requires two buffers and a long sequence of 32-bit words:",
    "title2_2b": "The two five 32-bit registers (“A, B, C, D, E” and “H0, H1, H2, H3, H4”) have specific initial values, and the sequence of 80 32-bit words (W[0], W[1], W[2]… W[78], W[79]).",
    "title2_3": "The core of the SHA-1 algorithm is a compression function that operates on a 160-bit message block and the current state of the message digest. It performs a series of operations, including bitwise logical functions, message expansion, and modular addition.",
    "title2_4": "The compression function is applied iteratively to each message block, updating the message digest state as each block is processed. The final output is the hash value of the input message.",
    "title2_5": "Each block goes through a complex process of expansion and 80 rounds of compression of 20 steps each. The value obtained after each compression is added to the current buffer (hash state).",
    "title2_6": "The resulting hash value is a fixed-size digest of 160 bits. It represents a unique fingerprint of the input message, making it highly improbable for two different messages to produce the same hash value.",
    "title3_1": "One of the main vulnerabilities of SHA-1 is its reduced collision resistance. A collision occurs when two different inputs produce the same hash output. In 2005, researchers demonstrated a theoretical collision attack on SHA-1, and in 2017, an actual collision attack was successfully executed, highlighting the practical security risks.",
    "title3_2": "Due to the identified vulnerabilities, SHA-1 is considered deprecated and not recommended for use in new cryptographic applications. Instead, stronger hash functions like SHA-256 or higher certificates are advised for improved security.",
    "title3_3a": "Widely used in:",
    "title3_3b": "- Security applications and protocols (e.g., TLS, SSL, PGP, SSH, S/MIME, Ipsec)",
    "title3_3c": "- Cryptocurrencies transactions validation",
    "title3_3d": "- Digital certificates"
  },
  "sha2": {
    "title1": "SHA-2 Origin",
    "title2": "SHA-2 Description",
    "title3": "SHA-2 Security / Usage",
    "title1_1": "The successor of SHA-1, approved and recommended by NIST, SHA-2 is a family of six algorithms with different digest sizes (in bits): SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256. The first four use the same construction with different output sizes, while the last two are truncated versions of SHA-512, where the initial values are generated using the method described in",
    "title1_2a": "Three main purposes of a hash function are:",
    "title1_2b": "- To scramble data deterministically",
    "title1_2c": "- To accept an input of arbitrary length and output a fixed-length result",
    "title1_2d": "- To manipulate data irreversibly",
    "title1_3": "The input cannot be derived from the output SHA-2 is a strong family of hash functions because, as you would expect, it serves all the purposes mentioned above.",
    "title2_1": "The input message is processed in blocks of 512 bits. If the message length is not a multiple of 512 bits, padding is added to the message to bring it to the appropriate length. The padding includes a \"1\" bit followed by a series of \"0\" bits, and the length of the original message is appended.",
    "title2_2": "The buffer is represented as eight 32-bit registers (A, B, C, D, E, F, G, H).",
    "title2_3": "The message is broken into 512 bits chunks, and each chunk goes through a complex process and 64 rounds of compression. The value obtained after each compression is added to the current hash value.",
    "title2_4": "The final hash value or digest is concatenated (linked together) based on all of the chunk values resulting from the processing step.",
    "title3_1": "SHA-2 is known for its security (it hasn't broken down like SHA-1) and its speed. In cases where keys are not generated, such as proof-of-work Bitcoin mining, a fast hash algorithm like SHA-2 often has the upper hand.",
    "title3_2a": "SHA-256 is useful in so many circumstances! It's a fast and secure hash function, here are some of the most common ways that it's used:",
    "title3_2b": "- To create website authentication schemes, using JWTs, HMACs and MACs",
    "title3_2c": "- To create digital signatures",
    "title3_2d": "- To secure blockchains like Bitcoin and Ethereum",
    "title3_2e": "- In anti-viruses, to compare the fingerprints of files and programs",
    "title3_2f": "- In version control systems like Git to check if data has changed",
    "title3_3": "After all, in SHA-256 there are 2^256 (1.158 x 10^77) possible outputs."
  },
  "chacha": {
    "title1": "ChaCha Eredet",
    "title2": "ChaCha Leírás",
    "title3": "ChaCha Biztonság / Alkalmazások",
    "title1_1": "A ChaCha20 egy szimmetrikus kulcsú folyamtitkosítási algoritmus, amelyet Daniel J. Bernstein tervezett. A tervezési folyamat során Bernstein a Salsa20 algoritmust alakította át, hogy még hatékonyabbá és biztonságosabbá tegye. A ChaCha20 népszerűvé vált a biztonságos kommunikációban, különösen a Transport Layer Security (TLS) protokollban.",
    "title2_1": "A ChaCha20 működése a következő lépésekben valósul meg:",
    "title2_2": "Kulcs és iv inicializálása: A titkosítás előtt a ChaCha20-hoz egy 256 bites kulcsot és egy 64 bites kezdőértéket, azaz iv-t (initialization vector) kell generálni.",
    "title2_3": "Blokkok generálása: A ChaCha20 a kulcs és az iv segítségével generál egy sorozatot 512 bites blokkokból. A blokkokat egy belső állapotmátrix segítségével hozza létre.",
    "title2_4": "Titkosítás: Az eredeti adatokat blokkokra osztják, majd ezeket az adatblokkokat az előző lépésben generált blokkokkal exkluzív VAGY művelettel kombinálják. Ez a lépés a titkosítást végzi.",
    "title2_5": "Eredmény kimenetele: A titkosított adatblokkokat összefűzik, és a végkimenetet kapjuk.",
    "title3_1": "A ChaCha20 algoritmus gyors és hatékony titkosítást biztosít, és ellenálló a legtöbb ismert támadás típussal szemben. Ezért egy népszerű és megbízható választás a biztonságos kommunikációban és adatvédelemben. A ChaCha20 jelenleg sok alkalmazásban és protokollban használatos a titkosítás és hitelesítés terén. Néhány példa a következő:",
    "title3_2": "TLS 1.3: A ChaCha20-Poly1305 kombinációja az egyik kiválasztott titkosítási algoritmus a TLS 1.3-ban, amely biztosítja a weboldalak és a felhasználók közötti biztonságos kapcsolatot. Ez a kombináció hatékony és biztonságos titkosítást és hitelesítést biztosít.",
    "title3_3": "IPsec: Az IPsec (Internet Protocol Security) protokollban is használható a ChaCha20 a virtuális magánhálózatok (VPN) kialakításához. Az IPsec segítségével biztonságos adatátvitel valósítható meg hálózatok között.",
    "title3_4": "Messaging alkalmazások: Néhány biztonságos üzenetküldő alkalmazás, például a Signal és a WhatsApp, a ChaCha20 algoritmust használja a végpontok közötti titkosításra. Ez lehetővé teszi a felhasználóknak, hogy bizalmas üzeneteket küldjenek és fogadjanak, megőrizve az adatok biztonságát.",
    "title3_5": "Internet Engineering Task Force (IETF) protokollok: A ChaCha20-Poly1305 algoritmus széles körben alkalmazott az IETF által elfogadott protokollokban, például a Datagram Transport Layer Security (DTLS) és a Secure Real-time Transport Protocol (SRTP) esetén."
  },
  "blowfish": {
    "title1": "Blowfish Eredet",
    "title2": "Blowfish Leírás",
    "title3": "Blowfish Biztonság / Alkalmazások",
    "title1_1": "A Blowfish egy blokktitkosítási algoritmus, amelyet Bruce Schneier tervezett 1993-ban. Az algoritmus tervezésekor Schneier arra törekedett, hogy egy hatékony és biztonságos titkosítási rendszert hozzon létre. A Blowfish algoritmus hosszú ideig népszerű és széles körben használt volt, bár ma már kevésbé elterjedt.",
    "title2_1": "Most tekintsünk részletesebben a Blowfish működésére:",
    "title2_2": "Kulcs kiterjesztése: A Blowfish kezdeti állapotát a kulcs segítségével állítja be. A kulcs hossza lehet 32-448 bit között.",
    "title2_3": "Blokkok osztása és iterációk: A bemeneti adatokat 64 bites blokkokra osztják, majd az algoritmus többször végrehajtja az ún. iterációkat. Minden iteráció során a blokkokat a kulcs speciális részeivel kombinálják.",
    "title2_4": "F-érték kiszámítása: Az iterációk során kiszámítják az F-függvény értékét. Ez a függvény a Blox függvényt használja, amely kombinálja a bemenet és a kulcs részeit.",
    "title2_5": "Titkosítás és dekódolás: Az iterációk végén a blokkok a végleges állapotba kerülnek, és ez a kimeneti titkosított adat vagy a dekódolt eredeti adat.",
    "title3_1": "A Blowfish működése során az iterációk száma határozza meg az algoritmus biztonsági szintjét. Minél több iterációt használnak, annál biztonságosabbá válik a titkosítás, de ez hatással lehet a teljesítményre is.",
    "title3_2": "Fontos megjegyezni, hogy a Blowfish algoritmus a hatékony és biztonságos titkosítás terén népszerű volt, de azóta biztonsági kérdések és újabb algoritmusok megjelenése miatt a legújabb ajánlásokban már kevésbé szerepel. Az Advanced Encryption Standard (AES) ma általánosan elfogadott és széles körben használt blokktitkosítási algoritmus.",
    "title3_3": "A Blowfish jelenleg is néhány alkalmazásban használatos, például:",
    "title3_4": "Adatbázis titkosítás: A Blowfishet néha alkalmazzák adatbázisrendszerekben a tárolt adatok védelmére. Például a MySQL adatbázisrendszerekben a Blowfish titkosítást lehet alkalmazni a tárolt adatok védelmére.",
    "title3_5": "Fájltitkosítás: A Blowfish algoritmust lehet alkalmazni fájlok titkosítására is. Ez lehetővé teszi a felhasználók számára, hogy bizalmas fájlokat védenek a hozzáférés elől.",
    "title3_6": "Virtual Private Network (VPN): Néhány VPN szolgáltatás még mindig használja a Blowfish titkosítási algoritmust a biztonságos adatátvitelhez. Bár az AES (Advanced Encryption Standard) népszerűbbé vált, a Blowfish továbbra is támogatott lehetőség marad bizonyos VPN-k esetében."
  },
  "whirlpool": {
    "title1": "Whirlpool Eredet",
    "title2": "Whirlpool Leírás",
    "title3": "Whirlpool Biztonság / Alkalmazások",
    "title1_1": "A Whirlpool egy hash-függvény, amelyet Vincent Rijmen és Paulo S. L. M. Barreto tervezett. A tervezési folyamat során céljuk egy biztonságos és hatékony hash-algoritmus létrehozása volt. A Whirlpool 2000-ben vált nemzetközileg elfogadott standarddá.",
    "title2_1": "Most tekintsünk részletesebben a Whirlpool működésére:",
    "title2_2": "Bemenet előkészítése: A bemeneti adatokat először kiegészítik, hogy megfeleljenek a blokkméretnek.",
    "title2_3": "Bemeneti blokkok feldolgozása: A bemenetet blokkokra osztják, majd ezeket a blokkokat feldolgozzák a Whirlpool belső állapotában.",
    "title2_4": "Permutáció és helyettesítés: A blokkokat a permutációs és helyettesítési fázis során többször kombinálják. Ez magában foglalja a mátrix helyettesítését, a bitcserét és a bitenkénti exkluzív VAGY műveleteket.",
    "title2_5": "Kibővítés és összeadás: A feldolgozott blokkokat a belső állapotmátrixhoz hozzáadják, majd a kibővített és összeadott értéket kapjuk.",
    "title2_6": "Végeredmény kimenetele: A feldolgozás során keletkező végső értékeket összeadják, és ez a Whirlpool hash-értékének kimenete.",
    "title3_1": "A Whirlpool hash-függvény nagy biztonságot és ellenállást nyújt a kriptoanalitikai támadásokkal szemben. Alkalmazása során figyelembe kell venni a bemeneti adatok előkészítését és a hash-érték hosszát a konkrét alkalmazáshoz igazítva.",
    "title3_2": "Fontos megjegyezni, hogy a Whirlpool hash-függvény egy régebbi algoritmus, és jelenleg a SHA-3 (Secure Hash Algorithm 3) hash-függvény ajánlott a legfrissebb biztonsági követelményeknek való megfeleléshez.",
    "title3_3": "A Whirlpool jelenleg is használatban van több különböző területen, például:",
    "title3_4": "Digitális aláírások: A Whirlpool hash-függvényt alkalmazzák digitális aláírások létrehozásához. Segít az adatok integritásának ellenőrzésében és a digitális aláírások biztonságában.",
    "title3_5": "Jelszó tárolás: A Whirlpool hash-függvényt néha használják jelszavak tárolásához. A jelszavakat először a hash-függvénnyel alakítják át, majd a hash-értéket tárolják a rendszerben. Ez biztonságosabbá teszi a jelszavak tárolását, mivel a hash-érték alapján nem lehet visszafejteni a jelszót."
  },
  "bcrypt": {
    "title1": "bcrypt Eredet",
    "title2": "bcrypt Leírás",
    "title3": "bcrypt Biztonság / Alkalmazások",
    "title1_1": "A bcrypt egy hash-függvény, amelyet Niels Provos és David Mazières tervezett. A tervezési folyamat során céljuk egy biztonságos és hatékony hash-algoritmus létrehozása volt. A bcrypt 1999-ben vált nemzetközileg elfogadott standarddá.",
    "title2_1": "Most tekintsünk részletesebben a bcrypt működésére:",
    "title2_2": "A bcrypt hash függvény két fő részből áll: a sózásból és az iteratív kriptográfiából. A sózás egy véletlenszerűen generált érték (só), amelyet a jelszóval együtt hash-elnek. Ez biztosítja, hogy két azonos jelszó különböző hash értéket kapjon.",
    "title2_3": "Az iteratív kriptográfia azt jelenti, hogy a bcrypt hash függvényt többször futtatják a jelszó és a só kombinációján. Ez a folyamat lassítja a hashelést, ami megnehezíti a támadóknak a brute force vagy a szivárgott jelszavak felhasználásával történő támadásokat.",
    "title3_1": "A bcrypt hash függvény kiemelkedően biztonságos a jelszavak tárolására. A sózás és az iteratív kriptográfia kombinációja hatékonyan ellenáll a brute force támadásoknak és a szivárgott jelszavak kihasználásának.",
    "title3_2": "A bcrypt hash függvény alkalmas a jelszavak ellenőrzésére is. Amikor egy felhasználó bejelentkezik, a rendszer hash-eli a megadott jelszót és összehasonlítja azt a tárolt hash értékkel. Ez lehetővé teszi, hogy a rendszer meghatározza, hogy a megadott jelszó helyes-e, anélkül hogy magát a jelszót tárolná vagy kiszivárogtathatná.",
    "title3_3": "A bcrypt hash függvény a jelenlegi legjobb gyakorlatok közé tartozik a jelszó tárolásában, és ajánlott minden olyan alkalmazásban, ahol a felhasználók jelszavakat használnak. Fontos megjegyezni, hogy a függvényt megfelelő módon kell beállítani, például megfelelő sózást és iterációs számot kell használni ahhoz, hogy maximális biztonságot nyújtson."
  }
}
