{
  "base": {
    "crypt": "Crypt",
    "learning": "Learning",
    "logout": "Logout",
    "login": "Login",
    "submit": "Submit",
    "welcomeTitle": "Welcome at Cryptorithm!",
    "welcomeText1": "Cryptorithm is an online cryptography application that allows you to try out different cryptographic systems and increase your knowledge of cryptography. Explore the exciting world of encryption and decryption and learn how different cryptographic methods work.",
    "welcomeText2": "Click on the \"Login\" button to create a new profile or log in to an existing one. Explore the cryptographic tools available, experiment with different algorithms, and see how data encryption and decryption are changing.",
    "welcomeText3": "Want to know more about the world of cryptography? Visit the \"Learning\" section where you will find detailed information on the origins, operation and uses of cryptographic systems."
  },
  "cryptorithm": {
    "login": "Login",
    "email": "Email",
    "password": "Password",
    "no_account": "Don't have an account?",
    "signup": "Sign Up",
    "password_confirm": "Password (Confirm)",
    "already_account": "Already have an account?"
  },
  "home": {
    "history": "History",
    "choose": "Choose an algortihm: ",
    "submit": "Submit",
    "placeholder": "Enter your text here...",
    "none": "None"
  },
  "learning": {
    "learn_about": "Learn about!",
    "list1": "Classic Cipher",
    "list2": "Stream Cipher",
    "list3": "Block Cipher",
    "list4": "Hash",
    "next": "Next",
    "previous": "Previous"
  },
  "caesar": {
    "title1": "Caesar - Origin",
    "title2": "Caesar - Description",
    "title3": "Caesar - Key / Security",
    "title1_1": "The Caesar cipher is named after Julius Caesar, the ancient Roman military and political leader who is believed to have used this encryption technique. The cipher is attributed to him, although it is likely that similar techniques were used even earlier. Julius Caesar used the Caesar cipher to protect sensitive military information during his campaigns. The shift of letters provided a simple and effective way to conceal messages from enemies who might intercept them.",
    "title1_2": "The method involves shifting each letter in the plaintext by a fixed number of positions, with Caesar's preferred shift being three positions. For example, if the plaintext is \"ATTACK AT DAWN\", the ciphertext generated using Caesar's cipher is \"DWWDFN DW GDZQ\".",
    "title2_1": "Each letter is encrypted one by one with a different letter, i.e. the letters are replaced one by one by the letter code assigned to them, always assigning the same letter code to a letter. Which letter is replaced by which letter is determined by the key k, which is an integer in the original system. A letter will thus always be replaced by a letter k positions to the right of the letter, and it is assumed that the letters are arranged in a circle, i.e. the letter A is again placed after the letter Z.",
    "title2_2": "Mathematically, it is defined by the following formula, where the letter p is the numeric code, the letter k is the offset value (key) and c is the secret numeric code:",
    "title2_3": "The decryption formula is the inverse of this, assuming that the encrypted letter is c, then the mathematical formula is:",
    "title3_1": "The key in the Caesar cipher is the number of positions each letter is shifted. For example, a key of 3 means each letter is shifted three positions down the alphabet.",
    "title3_2": "The Caesar cipher is a very basic and easily breakable cipher. It has only 26 possible keys, making it vulnerable to brute-force attacks. It is often used as an introductory example in cryptography, but it is not secure for practical purposes."
  },
  "affin": {
    "title1": "Affin - Origin",
    "title2": "Affin - Description",
    "title3": "Affin - Security / Example",
    "title1_1": "The Affine cipher has its roots in ancient civilizations. It is believed to have been used by the Romans around the 1st century BC. The Roman military commander Julius Caesar is often associated with an early version of the Affine cipher, known as the Caesar cipher or Caesar's cipher.",
    "title1_2": "The concept of the Affine cipher as a generalization of the Caesar cipher emerged later. The Affine cipher was developed as a more advanced cryptographic technique that allowed for a wider range of encryption possibilities.",
    "title2_1": "The Affine cipher is based on the mathematical concept of an affine transformation. An affine transformation is a linear function that combines two operations: a multiplication (modular arithmetic) and an addition (modulo operation).",
    "title2_2": "The parameters used in the Affine cipher are the encryption key ('a') and the modular arithmetic base ('b'). Assuming that 'p' is the numerical code of a letter in the plaintext and 'c' is its corresponding to the encrypted numeric code, the encryption formula is as follows:",
    "title2_3a": "If the",
    "title2_3b": "is the multiplicative inverse of the number 'a' according to 26, i.e the following relation holds:",
    "title2_4": "then the decryption formula will be:",
    "title3_1": "Over time, cryptanalysts have developed techniques to break the Affine cipher. The simplicity of the algorithm and the limited key space make it susceptible to brute-force attacks and frequency analysis methods.",
    "title3_2": "Although the Affine cipher is no longer considered secure for modern cryptographic purposes, it is still studied and used in educational settings to illustrate fundamental concepts of encryption and decryption. It serves as an introduction to more complex ciphers and cryptographic techniques."
  },
  "aes": {
    "title1": "AES Origin",
    "title2": "AES-CTR Description",
    "title3": "AES-CTR Security",
    "title1_1": "AES (Advanced Encryption Standard), also known as Rijndael, is a symmetric block cipher cryptosystem, which was standardized by the NIST in 2001. The system was developed by two Belgian cryptographers, Vincent Rijmen and Joan Daemen, and the name Rijndael is a contraction of their names.",
    "title1_2": "The block ciphers are schemes for encryption or decryption where a block of plaintext is treated as a single block and is used to obtain a block of ciphertext with the same size. Today, AES is one of the most used algorithms for block encryption. The size of an AES block is 128 bits, whereas the size of the encryption key can be 128, 192 or 256 bits. Please note this, there is three length in the key, but the size of the encryption block always is 128 bits.",
    "title1_3a": "Most popular modes: ECB, CBC, CFB, OFB, CTR",
    "title1_3b": "In this case we are discussing the CTR (short for counter) mode. At this mode of operation as an input block to the encryptor, i.e. as an IV, the value of a counter (Counter, Counter + 1,…, Counter + N - 1) is used. It also is a stream encryptor.",
    "title1_4a": "Pros:",
    "title1_4b": "- No padding",
    "title1_4c": "- Supports parallel computing",
    "title1_4d": "- Encryption and decryption use the same structure",
    "title1_4e": "- Bad block only affect the current block",
    "title1_4f": "Cons:",
    "title1_4g": "- A MITM (Man in the Middle) can change some ciphertext damaged plaintext",
    "title2_1": "A secret symmetric key is generated or provided. The AES algorithm takes this key and expands it into a set of round keys that will be used in the subsequent encryption process.",
    "title2_2": "An Initialization Vector is a unique value that is required for the CTR mode. The IV can be generated randomly or derived from a nonce (number used once) and a counter. The IV should be unique for each encryption operation to maintain security. The counter value is initialized based on the IV. The counter is a unique value that is incremented for each block of plaintext or ciphertext.",
    "title2_3": "AES-CTR operates by dividing the plaintext into fixed-size blocks (e.g., 128 bits). For each block, the counter value is encrypted using the AES algorithm and the round keys generated in the key expansion phase. This encryption of the counter produces a pseudorandom keystream.",
    "title2_4": "The pseudorandom keystream generated from the encryption step is then XORed with the corresponding plaintext block. The result of the XOR operation is the ciphertext block. This process is repeated for each block of plaintext, generating the complete ciphertext.",
    "title2_5a": "After each encryption or decryption operation, the counter value is incremented to ensure that a unique value is used for each block.",
    "title2_5b": "By using this process, AES-CTR transforms the AES block cipher into a stream cipher, generating a pseudorandom keystream that is combined with the plaintext or ciphertext through the XOR operation.",
    "title3_1": "To ensure security, the key in this mode need to be changed for every 2^(n/2) encryption blocks.",
    "title3_2a": "Attack modes:",
    "title3_2b": "- PA (Padding Attack)",
    "title3_2c": "- CPA (Chose Plaintext Attack)",
    "title3_2d": "- CCA (Choosen Ci)",
    "title3_3a": "It's commonly used in:",
    "title3_3b": "- Network Communication",
    "title3_3c": "- Disk and File Encryption",
    "title3_3d": "- Cloud Storage",
    "title3_3e": "- Real-Time Media Encryption",
    "title3_3f": "- Wireless Security"
  },
  "sha1": {
    "title1": "SHA-1 Origin",
    "title2": "SHA-1 Description",
    "title3": "SHA-1 Security",
    "title1_1a": "The SHA-1 (Secure Hash Algorithm 1) hash function, designed by the ",
    "title1_1b": "takes an input and produces a 160-bit (20-byte) hash value known as a message digest - typically rendered as 40 hexadecimal digits. SHA-1 is the most established of the existing SHA hash functions and it is used in a variety of security applications and protocols. However, SHA-1's collision resistance has been weakening as new attacks are discovered or improved.",
    "title2_1": "The input message is processed in blocks of 512 bits. If the message length is not a multiple of 512 bits, padding is added to the message to bring it to the appropriate length. The padding includes a \"1\" bit followed by a series of \"0\" bits, and the length of the original message is appended.",
    "title2_2a": "This algorithm requires two buffers and a long sequence of 32-bit words:",
    "title2_2b": "The two five 32-bit registers (“A, B, C, D, E” and “H0, H1, H2, H3, H4”) have specific initial values, and the sequence of 80 32-bit words (W[0], W[1], W[2]… W[78], W[79]).",
    "title2_3": "The core of the SHA-1 algorithm is a compression function that operates on a 160-bit message block and the current state of the message digest. It performs a series of operations, including bitwise logical functions, message expansion, and modular addition.",
    "title2_4": "The compression function is applied iteratively to each message block, updating the message digest state as each block is processed. The final output is the hash value of the input message.",
    "title2_5": "Each block goes through a complex process of expansion and 80 rounds of compression of 20 steps each. The value obtained after each compression is added to the current buffer (hash state).",
    "title2_6": "The resulting hash value is a fixed-size digest of 160 bits. It represents a unique fingerprint of the input message, making it highly improbable for two different messages to produce the same hash value.",
    "title3_1": "One of the main vulnerabilities of SHA-1 is its reduced collision resistance. A collision occurs when two different inputs produce the same hash output. In 2005, researchers demonstrated a theoretical collision attack on SHA-1, and in 2017, an actual collision attack was successfully executed, highlighting the practical security risks.",
    "title3_2": "Due to the identified vulnerabilities, SHA-1 is considered deprecated and not recommended for use in new cryptographic applications. Instead, stronger hash functions like SHA-256 or higher certificates are advised for improved security.",
    "title3_3a": "Widely used in:",
    "title3_3b": "- Security applications and protocols (e.g., TLS, SSL, PGP, SSH, S/MIME, Ipsec)",
    "title3_3c": "- Cryptocurrencies transactions validation",
    "title3_3d": "- Digital certificates"
  },
  "sha2": {
    "title1": "SHA-2 Origin",
    "title2": "SHA-2 Description",
    "title3": "SHA-2 Security / Usage",
    "title1_1": "The successor of SHA-1, approved and recommended by NIST, SHA-2 is a family of six algorithms with different digest sizes (in bits): SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256. The first four use the same construction with different output sizes, while the last two are truncated versions of SHA-512, where the initial values are generated using the method described in",
    "title1_2a": "Three main purposes of a hash function are:",
    "title1_2b": "- To scramble data deterministically",
    "title1_2c": "- To accept an input of arbitrary length and output a fixed-length result",
    "title1_2d": "- To manipulate data irreversibly",
    "title1_3": "The input cannot be derived from the output SHA-2 is a strong family of hash functions because, as you would expect, it serves all the purposes mentioned above.",
    "title2_1": "The input message is processed in blocks of 512 bits. If the message length is not a multiple of 512 bits, padding is added to the message to bring it to the appropriate length. The padding includes a \"1\" bit followed by a series of \"0\" bits, and the length of the original message is appended.",
    "title2_2": "The buffer is represented as eight 32-bit registers (A, B, C, D, E, F, G, H).",
    "title2_3": "The message is broken into 512 bits chunks, and each chunk goes through a complex process and 64 rounds of compression. The value obtained after each compression is added to the current hash value.",
    "title2_4": "The final hash value or digest is concatenated (linked together) based on all of the chunk values resulting from the processing step.",
    "title3_1": "SHA-2 is known for its security (it hasn't broken down like SHA-1) and its speed. In cases where keys are not generated, such as proof-of-work Bitcoin mining, a fast hash algorithm like SHA-2 often has the upper hand.",
    "title3_2a": "SHA-256 is useful in so many circumstances! It's a fast and secure hash function, here are some of the most common ways that it's used:",
    "title3_2b": "- To create website authentication schemes, using JWTs, HMACs and MACs",
    "title3_2c": "- To create digital signatures",
    "title3_2d": "- To secure blockchains like Bitcoin and Ethereum",
    "title3_2e": "- In anti-viruses, to compare the fingerprints of files and programs",
    "title3_2f": "- In version control systems like Git to check if data has changed",
    "title3_3": "After all, in SHA-256 there are 2^256 (1.158 x 10^77) possible outputs."
  },
  "chacha": {
    "title1": "ChaCha Origin",
    "title2": "ChaCha Description",
    "title3": "ChaCha Security / Usage",
    "title1_1": "ChaCha20 is a symmetric-key flow encryption algorithm designed by Daniel J. Bernstein. During the design process, Bernstein adapted the Salsa20 algorithm to make it more efficient and secure. ChaCha20 has become popular in secure communications, particularly in the Transport Layer Security (TLS) protocol",
    "title2_1": "ChaCha20 works in the following steps:",
    "title2_2": "Initialization of key and iv: Before encryption, ChaCha20 requires the generation of a 256-bit key and a 64-bit initialization vector (iv).",
    "title2_3": "Block generation: ChaCha20 uses the key and iv to generate a sequence of 512-bit blocks. The blocks are generated using an internal state matrix.",
    "title2_4": "Encryption: The original data is divided into blocks and these data blocks are combined with the blocks generated in the previous step using an exclusive OR operation. This step performs the encryption.",
    "title2_5": "Result output: the encrypted data blocks are combined and the final output is obtained.",
    "title3_1": "The ChaCha20 algorithm provides fast and efficient encryption and is resistant to most known attack types. It is therefore a popular and reliable choice for secure communications and data protection. ChaCha20 is currently used in many applications and protocols for encryption and authentication. Some examples are:",
    "title3_2": "TLS 1.3: The ChaCha20-Poly1305 combination is one of the selected encryption algorithms in TLS 1.3, which ensures secure connections between websites and users. This combination provides efficient and secure encryption and authentication.",
    "title3_3": "IPsec: ChaCha20 can also be used in the Internet Protocol Security (IPsec) protocol to create virtual private networks (VPNs). IPsec can be used for secure data transfer between networks.",
    "title3_4": "Messaging applications: Some secure messaging applications, such as Signal and WhatsApp, use the ChaCha20 algorithm for end-to-end encryption. This allows users to send and receive confidential messages while maintaining data security.",
    "title3_5": "Internet Engineering Task Force (IETF) Protocols."
  },
  "blowfish": {
    "title1": "Blowfish Origin",
    "title2": "Blowfish Description",
    "title3": "Blowfish Security / Usage",
    "title1_1": "Blowfish is a block encryption algorithm designed by Bruce Schneier in 1993. When designing the algorithm, Schneier aimed to create an efficient and secure encryption system. The Blowfish algorithm has been popular and widely used for a long time, although it is less common today",
    "title2_1": "Now let's take a closer look at how Blowfish works:",
    "title2_2": "Key extension: Blowfish uses the key to set its initial state. The length of the key can be between 32 and 448 bits.",
    "title2_3": "Block splitting and iterations: The input data is split into 64-bit blocks and the algorithm performs several iterations. In each iteration, the blocks are combined with specific parts of the key.",
    "title2_4": "Calculation of F-value: During the iterations, the value of the F-function is calculated. This function uses the Blox function, which combines the input and key parts.",
    "title2_5": "Encryption and Decryption: At the end of the iterations, the blocks are converted to the final state, which is the output encrypted data or the decrypted original data.",
    "title3_1": "The number of iterations during the operation of Blowfish determines the security level of the algorithm. The more iterations are used, the more secure the encryption becomes, but this can also have an impact on performance.",
    "title3_2": "It is important to note that the Blowfish algorithm was popular for efficient and secure encryption, but has since been less used in recent recommendations due to security issues and the emergence of newer algorithms. The Advanced Encryption Standard (AES) is now a widely accepted and widely used block cipher algorithm",
    "title3_3": "Blowfish is currently used in some applications, such as:",
    "title3_4": "Database encryption: Blowfish is sometimes used in database systems to protect stored data. For example, in MySQL database systems, Blowfish encryption can be used to protect stored data.",
    "title3_5": "File Encryption: The Blowfish algorithm can also be used to encrypt files. This allows users to protect confidential files from access",
    "title3_6": "Virtual Private Network (VPN): Some VPN services still use the Blowfish encryption algorithm for secure data transfer. Although Advanced Encryption Standard (AES) has become more popular, Blowfish remains a supported option for some VPNs."
  },
  "whirlpool": {
    "title1": "Whirlpool Origin",
    "title2": "Whirlpool Description",
    "title3": "Whirlpool Security / Usage",
    "title1_1": "Whirlpool is a hash function designed by Vincent Rijmen and Paulo S. L. M. Barreto. During the design process, their goal was to create a secure and efficient hash algorithm. Whirlpool became an internationally accepted standard in 2000",
    "title2_1": "Now let's take a closer look at how Whirlpool works:",
    "title2_2": "Input preparation: The input data is first completed to match the block size.",
    "title2_3": "Input block processing: The input is divided into blocks and then these blocks are processed in the internal state of the Whirlpool.",
    "title2_4": "Permutation and Substitution: Blocks are repeatedly combined during the permutation and substitution phase. This includes matrix substitution, bit swapping and bitwise exclusive OR operations.",
    "title2_5": "Expansion and Addition: The processed blocks are added to the internal state matrix and the expanded and added value is obtained.",
    "title2_6": "Output of the final result: The final values produced by the processing are summed and this is the output of the Whirlpool hash value.",
    "title3_1": "The Whirlpool hash function provides high security and resistance against cryptanalytic attacks. Its application should take into account the preparation of the input data and the length of the hash value adapted to the specific application.",
    "title3_2": "It is important to note that the Whirlpool hash function is an older algorithm and currently the SHA-3 (Secure Hash Algorithm 3) hash function is recommended to meet the latest security requirements.",
    "title3_3": "Whirlpool is currently in use in a number of different areas, including:",
    "title3_4": "Digital Signatures: The Whirlpool hash function is used to generate digital signatures. It helps to verify data integrity and secure digital signatures.",
    "title3_5": "Password Storage: The Whirlpool hash function is sometimes used to store passwords. Passwords are first converted by the hash function and then the hash value is stored in the system. This makes the storage of passwords more secure, as the password cannot be decrypted based on the hash value."
  },
  "bcrypt": {
    "title1": "bcrypt Origin",
    "title2": "bcrypt Description",
    "title3": "bcrypt Security / Usage",
    "title1_1": "bcrypt is a hash function designed by Niels Provos and David Mazières. Their design process was aimed at creating a secure and efficient hash algorithm. bcrypt became an internationally accepted standard in 1999",
    "title2_1": "Now let's take a closer look at how bcrypt works:",
    "title2_2": "The bcrypt hash function consists of two main parts: salting and iterative cryptography. Salting is a randomly generated value (salt) that is hashed together with the password. This ensures that two identical passwords have different hash values",
    "title2_3": "Iterative cryptography means that the bcrypt hash function is run multiple times on the combination of password and salt. This process slows down the hashing, making it more difficult for attackers to use brute force or leaked passwords.",
    "title3_1": "The bcrypt hash function is highly secure for storing passwords. The combination of salting and iterative cryptography effectively resists brute force attacks and the exploitation of leaked passwords.",
    "title3_2": "The bcrypt hash function is also suitable for password verification. When a user logs in, the system hashes the password and compares it with the stored hash value. This allows the system to determine if the password is correct without storing or leaking the password itself.",
    "title3_3": "The bcrypt hash function is a current best practice in password storage and is recommended for all applications where users use passwords. It is important to note that the function must be properly configured, such as using appropriate salt and iteration number, to provide maximum security."
  }
}
